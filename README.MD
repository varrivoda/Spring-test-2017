# ПРОКЛЯТИЕ SPRING TEST
Конспект выступления Е.Борисова и К.Толкачева на JPoint-2017
https://youtu.be/7mZqJShu_3c

    "..данный доклад не стоит записывать и воспринимать как cooking book, т.к. некоторыые вещи специадльно делаем неправильно, чтобы логически прийти к тому,как это делать правильно" 
-Борисов об импорте конфигураций на 14:00

# Сегодня в программе: Тестирование живого приложения:
-Старые подходы:
    @ContextConfiguration
    @ContextHierarchy && @DirtiesContext
    @ActiveProfiles
-Что нового от Spring Boot?
    @SpringBootTest
    @TestConfiguration
    @MockBean && @SpyBean && @*Beans
    @DataJpaTest
    @WebMvcTest
-Кеширование spring контекстов
-Шкала тестов

Мы не можем дать какой-то единой правильной методологии по TDD и показать все связанные с этим современные спринговые штуки. Цель доклада - показать технические возможности тестировать разные куски нашего микросервисы, ну и после всего этого поделиться определенными концепциями по поводу всего этого.

Какие тесты мы будем писать? 
Вообще на "шкале тестов" можно выделить следубщие масштабы:
    
    Unit -> Component -->-->--> Microservice -> System test 

Есть обычные юнит-тесты, которым ничего ненужно: через new созлаем объект, обкладываем все моками, тут всё понятно и без нас.

Следующий уровень - component-test,  это уже некая часть системы -например, у нас есть сервис, в который инжектится Дао, это работает с какой-то моковой БД... Компонентможет быть разного размера,например контроллер скаким-то сервисом..

И есть end-to-end тест, т е тест всего микросервиса, полностью от контроллера до базы, и единственное что будет мокироваться - это все его выходы, например к другим системам/микросервисам.

Последний - System test - сегодня рассматривать не будем.

# ЧАСТЬ 1, условия задачи

Наше приложение,которое мы будем тестировать - это чат поддержки, в котором есть эксперты, которые помогают разработчикам отвечать на вопросы.
                                   
                              ---  ???? --- 
                            |default answers| 
                            |   database    |
                              -- _______ --
                                    ^
     ______             ____________v__
    |__мы__| <--web--> |___assistant___| <----.
                        ^             |       |   
                      rest           rest    rest
              __________v______    ___v_______|______
             |jbaruch-assistant|  |yegor256-assistant| <--> Queue

Мы приходим в чат,и должны задать какой-то вопрос, и нам отвечает один из экспертов. 
asistant-сервис работает как роутер: получает вопрос, по ключевым словам понимает,ккакому эксперту обратиться, если ноль совпадений по ключевым словам онидет в базу дефолтных ответов.

Барух отвечает всегда одинаково, поэтому его ответы можно закешировать, и поэтому он отвечает гораздо быстрее. А Егор откладывает все свои вопросы в очередь, думает, надругой раз может и передумать и ответить отлично от прошлого раза, поэтому его ответы кешировать нельзя. 

# Часть 2, начинаем тестировать
Тестируем часть системы, которая отвечает за то, что запрос пойдет к Егору. Там у нас инжектятся какие-то токены - это ключевые слова, по которым мы знаем, что надо идти к Егору.
    
    package coom.conference.spring.test.webassistant.service.resolvers.words;
        
    @Cmponent
    Yegor256WordsFrequencyResolver extends AbstractWordsFrequencyResolver
    
    @Getter
    @Setter(PACKAGE)
    @Value("${tokens.yegor256}")
    private String answers;

    public Yegor256WordsFrequencyResolver(WordsComposer wordsComposer){
        super(wordsComposer);
    }
    
    @Override
    public QuestionType getQuestionType(){
        return YEGOR256;
    }

делаем create test... там Generate...test method
"С чего начинается тест? - С аппрува комплита" - new ЕгорСервис...
Мы пытаемся сделать юнит-тест,но выейчас быстропоммете,что это невозможно.
Мытестируем штуку,которая вскбе держит еще штуку,которая держит еще штуку,ит.д, получается не модульный тест, а тест компонента.
    
    public vois name() throwsException {
        new Yegor256WordsFrequencyResolver(
            new WordsCompose(
                new GarbageProperties()));

    //пока что вроде получается, укажем что он нат ответит
    Yegor256WordsFrequencyResolver.setAnswers("objects");
    
    //теперь вызываем логику нащего сервиса, чтобы посмотреть, что он нам отвечает
    // а он долджен нам вернуть, сколько слов в вопросе совпало с егоключевыми словами
    int match = Yegor256WordsFrequencyResolver.match(Question.builder().body("objects ...").build());
        
    //...ипроверим,что он нам вернул всечто надо
    assertThat(match, equalTo(1));
    }


(кстати, создадим скруктуру папок проекта, по скриншоту на таймкоде 7:36)

...запускаем, получаем NPE
Проходим в WordsComposer, смотрим - garbageProperties = null
Почему мы не можем его легко замокировать? Потому что он в принципе вычитывается из какого-то спрингового PropertySource, и в нем какая-то логика. Впринципе конечно можно... но не в этот раз.

Что это за garbage? механизм, который решает комупереадресовать, помимо всего прочего,отфильтровывает все мусорные слова, типа "я,не..." и т.д. И чтобы протестировать,надо этот проперти файл.... Короче давай уже спрингом.